name: Build Firmware

on:
  push:
    branches: [main, snd]
    paths-ignore:
      - '**/*.md'
      - 'docs/**'
      - 'images/**'
      - 'LICENSE'
      - '.gitignore'

env:
  IDF_VERSION: v5.5.2
  IDF_TARGET: esp32p4
  CCACHE_DIR: /opt/actions-runner-esp32/.ccache
  CCACHE_MAXSIZE: 1G
  CCACHE_COMPRESSLEVEL: 6

jobs:
  build:
    runs-on: self-hosted
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          clean: false

      - name: Check for skip CI
        id: check_skip
        run: |
          COMMIT_MSG=$(git log -1 --pretty=%B)
          if echo "$COMMIT_MSG" | grep -qi '\[skip ci\]'; then
            echo "Skipping CI due to [skip ci] in commit message"
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Read version
        if: steps.check_skip.outputs.skip != 'true'
        id: version
        run: |
          VERSION=$(cat version.txt | tr -d '[:space:]')
          SHORT_SHA=$(git rev-parse --short HEAD)
          BRANCH=${GITHUB_REF_NAME}
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT

      - name: Set ESP-IDF paths
        if: steps.check_skip.outputs.skip != 'true'
        run: |
          echo "IDF_PATH=$HOME/esp/esp-idf" >> $GITHUB_ENV
          echo "IDF_TOOLS_PATH=$HOME/esp/tools" >> $GITHUB_ENV

      - name: Ensure ESP-IDF ${{ env.IDF_VERSION }} is installed
        if: steps.check_skip.outputs.skip != 'true'
        run: |
          # Check if ESP-IDF is already installed and at the correct version
          if [ -f "$IDF_PATH/export.sh" ]; then
            INSTALLED_VERSION=$(git -C "$IDF_PATH" describe --tags --exact-match 2>/dev/null || echo "")
            if [ -z "$INSTALLED_VERSION" ] && [ -f "$IDF_PATH/version.txt" ]; then
              INSTALLED_VERSION="v$(cat "$IDF_PATH/version.txt" | tr -d '[:space:]')"
            fi
            echo "ESP-IDF found: ${INSTALLED_VERSION:-unknown}"
            if [ "$INSTALLED_VERSION" = "$IDF_VERSION" ]; then
              echo "Correct version already installed. Skipping."
              exit 0
            else
              echo "Version mismatch ($INSTALLED_VERSION != $IDF_VERSION). Reinstalling..."
              rm -rf "$IDF_PATH"
              rm -rf "$IDF_TOOLS_PATH"
            fi
          fi

          echo "Installing ESP-IDF $IDF_VERSION..."

          echo "::group::Clone ESP-IDF $IDF_VERSION"
          mkdir -p "$(dirname "$IDF_PATH")" "$(dirname "$IDF_TOOLS_PATH")"
          git clone --branch "$IDF_VERSION" --depth 1 --recursive \
            https://github.com/espressif/esp-idf.git "$IDF_PATH"
          echo "::endgroup::"

          echo "::group::Install ESP-IDF tools for $IDF_TARGET"
          "$IDF_PATH/install.sh" "$IDF_TARGET"
          echo "::endgroup::"

          echo "ESP-IDF $IDF_VERSION installation complete."

      - name: Setup ESP-IDF environment
        if: steps.check_skip.outputs.skip != 'true'
        run: |
          . $IDF_PATH/export.sh
          echo "IDF version: $(idf.py --version)"

      - name: Setup ccache
        if: steps.check_skip.outputs.skip != 'true'
        run: |
          # Install ccache if not present
          if ! command -v ccache &>/dev/null; then
            echo "Installing ccache..."
            sudo apt-get update -qq && sudo apt-get install -y -qq ccache
          fi
          echo "ccache version: $(ccache --version | head -1)"
          ccache --zero-stats
          ccache --show-config | grep -E "max_size|cache_dir|compression"

      - name: Build project
        if: steps.check_skip.outputs.skip != 'true'
        run: |
          . $IDF_PATH/export.sh
          idf.py build --ccache

      - name: Show ccache stats
        if: steps.check_skip.outputs.skip != 'true'
        run: |
          ccache --show-stats

      - name: Generate firmware binaries
        if: steps.check_skip.outputs.skip != 'true'
        run: |
          . $IDF_PATH/export.sh
          mkdir -p firmware

          # Detect app binary from project_description.json
          APP_BIN=$(python3 -c "
          import json
          with open('build/project_description.json') as f:
              d = json.load(f)
          print('build/' + d['app_bin'])
          ")

          # Merge factory binary (bootloader + partition table + app)
          python3 -m esptool --chip esp32p4 merge_bin \
            --flash_mode dio \
            --flash_size 32MB \
            --flash_freq 80m \
            -o firmware/nina-display-factory.bin \
            0x2000  build/bootloader/bootloader.bin \
            0x8000  build/partition_table/partition-table.bin \
            0x20000 "$APP_BIN"

          # Copy app binary as OTA file
          cp "$APP_BIN" firmware/nina-display-ota.bin

          # Report sizes
          echo "Factory: $(du -h firmware/nina-display-factory.bin | cut -f1)"
          echo "OTA:     $(du -h firmware/nina-display-ota.bin | cut -f1)"

      - name: Extract firmware metrics
        if: steps.check_skip.outputs.skip != 'true'
        id: metrics
        run: |
          . $IDF_PATH/export.sh
          
          # Get binary sizes
          FACTORY_SIZE=$(stat -c%s firmware/nina-display-factory.bin 2>/dev/null || stat -f%z firmware/nina-display-factory.bin)
          OTA_SIZE=$(stat -c%s firmware/nina-display-ota.bin 2>/dev/null || stat -f%z firmware/nina-display-ota.bin)
          
          # Convert to human readable using Python (bc not available on all runners)
          FACTORY_MB=$(python3 -c "print(f'{$FACTORY_SIZE / 1024 / 1024:.2f}')")
          OTA_MB=$(python3 -c "print(f'{$OTA_SIZE / 1024 / 1024:.2f}')")
          
          # Extract PSRAM config from sdkconfig (exact key match to avoid multi-line grep)
          PSRAM_SPEED=$(grep '^CONFIG_SPIRAM_SPEED=' sdkconfig 2>/dev/null | cut -d'=' -f2 || echo "200")

          # Get flash size from sdkconfig (exact key match)
          FLASH_SIZE=$(grep '^CONFIG_ESPTOOLPY_FLASHSIZE=' sdkconfig | cut -d'"' -f2 || echo "32MB")
          
          # Get memory usage from size output
          if [ -f build/nina-display.map ]; then
            DRAM_USED=$(grep -A 10 "Memory region.*Used Size" build/nina-display.map | grep "dram0" | awk '{print $2}' || echo "0")
            IRAM_USED=$(grep -A 10 "Memory region.*Used Size" build/nina-display.map | grep "iram0" | awk '{print $2}' || echo "0")
          else
            DRAM_USED="N/A"
            IRAM_USED="N/A"
          fi
          
          # Create metrics JSON
          cat > /tmp/firmware-metrics.json << EOF
          {
            "flash_size": "$FLASH_SIZE",
            "psram": "32MB @ ${PSRAM_SPEED}MHz",
            "factory_size": "${FACTORY_MB} MB",
            "ota_size": "${OTA_MB} MB",
            "dram_used": "$DRAM_USED",
            "iram_used": "$IRAM_USED",
            "esp_idf": "${{ env.IDF_VERSION }}",
            "target": "${{ env.IDF_TARGET }}",
            "build_date": "$(date -u +%Y-%m-%d)",
            "branch": "${GITHUB_REF_NAME}",
            "commit": "${{ steps.version.outputs.short_sha }}"
          }
          EOF
          
          cat /tmp/firmware-metrics.json
          
          echo "factory_mb=$FACTORY_MB" >> $GITHUB_OUTPUT
          echo "ota_mb=$OTA_MB" >> $GITHUB_OUTPUT

      - name: Update badge metrics
        if: steps.check_skip.outputs.skip != 'true' && github.ref == 'refs/heads/main'
        run: |
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Store current state
          CURRENT_BRANCH=${GITHUB_REF_NAME}
          CURRENT_COMMIT=$(git rev-parse HEAD)
          
          # Fetch badges branch if it exists, or create orphan
          git fetch origin badges:badges 2>/dev/null || git checkout --orphan badges
          
          # Switch to badges branch
          if git show-ref --verify --quiet refs/heads/badges; then
            git checkout badges
          fi
          
          # Clean all except .git
          git rm -rf . 2>/dev/null || true
          
          # Copy metrics file
          cp /tmp/firmware-metrics.json .
          
          # Commit and push
          git add firmware-metrics.json
          if git commit -m "Update firmware metrics for ${{ steps.version.outputs.short_sha }}"; then
            git push origin badges --force
          fi
          
          # Return to original state
          git checkout $CURRENT_COMMIT
          git checkout $CURRENT_BRANCH

      - name: Upload firmware artifacts
        if: steps.check_skip.outputs.skip != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: firmware-${{ steps.version.outputs.branch }}-${{ steps.version.outputs.short_sha }}
          path: firmware/
          retention-days: 30

      - name: Determine tag
        if: steps.check_skip.outputs.skip != 'true'
        id: tag
        run: |
          BRANCH=${GITHUB_REF_NAME}

          if [ "$BRANCH" = "main" ]; then
            VERSION=$(cat version.txt | tr -d '[:space:]')
            TAG="v${VERSION}"
          else
            # Use latest main release version so pre-releases sort correctly
            LATEST_MAIN_TAG=$(git tag -l 'v[0-9]*.[0-9]*.[0-9]*' --sort=-v:refname | grep -v '-' | head -1)
            if [ -n "$LATEST_MAIN_TAG" ]; then
              BASE_VERSION=${LATEST_MAIN_TAG#v}
            else
              BASE_VERSION=$(cat version.txt | tr -d '[:space:]')
            fi
            # Count existing tags with this prefix to auto-increment
            PREFIX="v${BASE_VERSION}-${BRANCH}."
            EXISTING=$(git tag -l "${PREFIX}*" | wc -l)
            NEXT=$((EXISTING + 1))
            TAG="v${BASE_VERSION}-${BRANCH}.${NEXT}"
          fi

          echo "tag=$TAG" >> $GITHUB_OUTPUT
          if [ "$BRANCH" = "main" ]; then
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
          else
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
          fi

      - name: Generate changelog
        if: steps.check_skip.outputs.skip != 'true'
        id: changelog
        run: |
          PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
          if [ -n "$PREV_TAG" ]; then
            CHANGES=$(git log ${PREV_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
          else
            CHANGES=$(git log --pretty=format:"- %s (%h)" --no-merges -20)
          fi
          echo "$CHANGES" > /tmp/changelog.txt
          echo "prev_tag=$PREV_TAG" >> $GITHUB_OUTPUT

      - name: Check for network_adapter.bin
        if: steps.check_skip.outputs.skip != 'true'
        id: network_adapter
        run: |
          if [ -f "network_adapter.bin" ]; then
            cp network_adapter.bin firmware/
            echo "included=true" >> $GITHUB_OUTPUT
          else
            echo "included=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate release notes
        if: steps.check_skip.outputs.skip != 'true'
        run: |
          TAG="${{ steps.tag.outputs.tag }}"
          PREV_TAG="${{ steps.changelog.outputs.prev_tag }}"
          VERSION=$(cat version.txt | tr -d '[:space:]')
          BRANCH=${GITHUB_REF_NAME}
          FACTORY_MB="${{ steps.metrics.outputs.factory_mb }}"
          OTA_MB="${{ steps.metrics.outputs.ota_mb }}"

          if [ -n "$PREV_TAG" ]; then
            COMPARE_URL="https://github.com/chvvkumar/ESP32-P4-NINA-Display/compare/${PREV_TAG}...${TAG}"
          else
            COMPARE_URL=""
          fi

          export TAG PREV_TAG VERSION BRANCH COMPARE_URL FACTORY_MB OTA_MB
          python3 << 'PYEOF'
          import os, json
          tag = os.environ['TAG']
          prev_tag = os.environ.get('PREV_TAG', '')
          version = os.environ['VERSION']
          branch = os.environ['BRANCH']
          compare_url = os.environ.get('COMPARE_URL', '')
          factory_mb = os.environ.get('FACTORY_MB', 'N/A')
          ota_mb = os.environ.get('OTA_MB', 'N/A')
          
          # Load metrics if available
          try:
              with open('/tmp/firmware-metrics.json') as f:
                  metrics = json.load(f)
          except:
              metrics = {}
          
          with open('/tmp/changelog.txt') as f:
              changes = f.read().strip()
          since = f'### Changes since {prev_tag}' if prev_tag else '### Recent Changes'
          lines = [
              f'## NINA Display {tag}',
              '',
              f'**Branch:** {branch}',
              f'**Version:** {version}',
              '**Built with:** ESP-IDF v5.5.2',
              '',
              '### Build Specifications',
              f'- **Target:** {metrics.get("target", "esp32p4")}',
              f'- **Flash Size:** {metrics.get("flash_size", "32MB")}',
              f'- **PSRAM:** {metrics.get("psram", "32MB @ 200MHz")}',
              f'- **Factory Binary:** {factory_mb} MB',
              f'- **OTA Binary:** {ota_mb} MB',
              '',
              since,
              changes,
              '',
          ]
          if compare_url:
              lines.append(f'**Full Changelog**: {compare_url}')
              lines.append('')
          lines += [
              '### Firmware Files',
              '| File | Description |',
              '|------|-------------|',
              '| `nina-display-factory.bin` | Full factory image (flash at 0x0000) |',
              '| `nina-display-ota.bin` | OTA update binary (upload via web UI) |',
              '',
              '### Flashing',
              '- **Factory:** Use [ESP Web Flasher](https://espressif.github.io/esptool-js/) â€” flash at address `0x0000`',
              '- **OTA:** Upload `nina-display-ota.bin` via the device web UI at `http://<device-ip>/`',
              '',
          ]
          with open('/tmp/release-notes.md', 'w') as f:
              f.write('\n'.join(lines))
          PYEOF

      - name: Create release
        if: steps.check_skip.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ steps.tag.outputs.tag }}"
          IS_PRERELEASE=${{ steps.tag.outputs.is_prerelease }}

          PRERELEASE_FLAG=""
          if [ "$IS_PRERELEASE" = "true" ]; then
            PRERELEASE_FLAG="--prerelease"
          fi

          # Create or move git tag to current commit
          git tag -f "$TAG"
          git push origin "$TAG" --force

          # Delete existing release if present, then create fresh
          gh release delete "$TAG" --yes 2>/dev/null || true
          gh release create "$TAG" \
            firmware/nina-display-factory.bin \
            firmware/nina-display-ota.bin \
            --title "$TAG" \
            --notes-file /tmp/release-notes.md \
            $PRERELEASE_FLAG

      - name: Bump version for next release
        if: steps.check_skip.outputs.skip != 'true' && github.ref == 'refs/heads/main'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          CURRENT_VERSION=$(cat version.txt | tr -d '[:space:]')
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          PATCH=$((PATCH + 1))
          NEW_VERSION="$MAJOR.$MINOR.$PATCH"

          echo "$NEW_VERSION" > version.txt
          echo "Bumped version: $CURRENT_VERSION -> $NEW_VERSION"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add version.txt
          git commit -m "chore: bump version to $NEW_VERSION [skip ci]"
          git push origin main
